import { AdvancementClass, LootTableClass, PredicateClass, RecipeClass, TagClass } from "../resources/index";
import type { AdvancementType, LootTableType, PredicateType, RecipeType, TAG_TYPES } from "../arguments/index";
import type { Datapack } from "./index";
import type { HintedTagStringType } from "../resources/index";
import type { MCFunctionInstance } from "./Datapack";
import type { TagSingleValue } from "./resourcesTree";
/** The namespace all nested resources will be located in. */
export declare type BasePathOptions<N extends (undefined | string), D extends (undefined | string)> = {
    namespace?: N;
    /** The directory all nested resources will be located in. */
    directory?: D;
};
/** Changes the base namespace & directory of nested resources. */
export declare class BasePathClass<N extends (undefined | string), D extends (undefined | string)> {
    protected datapack: Datapack;
    namespace: N;
    directory: D;
    constructor(datapack: Datapack, basePath: BasePathOptions<N, D>);
    /** Validates & crafts the name of a resource. */
    protected getName(name: string): string;
    /**
     * Get a child path of the current base path.
     *
     * The namespace cannot be provided in a child path.
     */
    child: <DIR extends string | undefined>(childPath: Pick<BasePathOptions<undefined, DIR>, "directory">) => BasePathClass<N, string>;
    /**
     * Creates a Minecraft Function.
     *
     * @param name The name of the function.
     * @param callback A callback containing the commands you want in the Minecraft Function.
     */
    MCFunction: <RETURN extends void | Promise<void>>(name: string, callback: () => RETURN, options?: ({
        lazy?: boolean | undefined;
        debug?: boolean | undefined;
        runOnLoad?: boolean | undefined;
        tags?: readonly (string | TagClass<"functions">)[] | undefined;
    } & {
        runEachTick?: boolean | undefined;
    }) | ({
        lazy?: boolean | undefined;
        debug?: boolean | undefined;
        runOnLoad?: boolean | undefined;
        tags?: readonly (string | TagClass<"functions">)[] | undefined;
    } & {
        runEach?: number | (Pick<string, never> & {
            trimStart: () => string;
        }) | "1t" | "1s" | "1d" | undefined;
    }) | undefined) => MCFunctionInstance<RETURN>;
    /**
     * Create an advancement.
     *
     * @param advancement The actual advancement. You must provide at least a `criteria` for it to be valid.
     *
     * @example
     *
     * Advancement('bred_two_cows', {
     *   criteria: {
     *     'bred_cows': {
     *       trigger: 'minecraft:bred_animals',
     *       conditions: {
     *         child: { type: 'minecraft:cow' }
     *       }
     *     }
     *   }
     * })
     */
    Advancement: <T extends string>(name: string, advancement: AdvancementType<T>) => AdvancementClass<T>;
    /**
     * Create a predicate.
     *
     * @param predicate The actual predicate. You must provide at least a `condition` for it to be valid.
     *
     * @example
     *
     * Predicate('is_raining', {
     *   condition: 'minecraft:weather_check',
     *   raining: true,
     * })
     */
    Predicate: (name: string, predicate: PredicateType) => PredicateClass;
    /** Create a tag. */
    Tag: <T extends TAG_TYPES>(type: T, name: string, values?: TagSingleValue<HintedTagStringType<T>>[], replace?: boolean | undefined) => TagClass<T>;
    /**
     * Create a loot table.
     *
     * @param lootTable The actual loot table. Each pool must provide a number of `rolls` and a list of `entries` to be valid.
     * Each entry must at least provide its `type` and the type-dependant required properties.
     *
     * @example
     *
     * LootTable('give_diamond', {
     *   pools: [{
     *     rolls: 1,
     *     entries: [{
     *       type: 'item',
     *       name: 'minecraft:diamond',
     *     }],
     *   }],
     * })
     */
    LootTable: (name: string, lootTable: LootTableType) => LootTableClass;
    /** Create a recipe. */
    Recipe: <P1 extends string, P2 extends string, P3 extends string>(name: string, recipe: RecipeType<P1, P2, P3>) => RecipeClass<P1, P2, P3>;
}
