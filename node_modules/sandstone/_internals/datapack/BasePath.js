"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePathClass = void 0;
const index_1 = require("../resources/index");
/** Remove forward & trailing slashes */
function trimSlashes(str) {
    var _a;
    return (_a = str.replace(/^\/+/, '')) === null || _a === void 0 ? void 0 : _a.replace(/\/+$/, '');
}
/** Tranforms a path to an array of folders. */
function pathToArray(path) {
    return (path !== null && path !== void 0 ? path : '').split('/');
}
/** Changes the base namespace & directory of nested resources. */
class BasePathClass {
    constructor(datapack, basePath) {
        /**
         * Get a child path of the current base path.
         *
         * The namespace cannot be provided in a child path.
         */
        this.child = (childPath) => {
            const newDirectory = pathToArray(typeof childPath.directory === 'string' ? trimSlashes(childPath.directory) : undefined);
            const oldDirectory = pathToArray(this.directory);
            return new BasePathClass(this.datapack, {
                namespace: this.namespace,
                directory: [...oldDirectory, ...newDirectory].join('/'),
            });
        };
        /**
         * Creates a Minecraft Function.
         *
         * @param name The name of the function.
         * @param callback A callback containing the commands you want in the Minecraft Function.
         */
        this.MCFunction = (name, callback, options) => {
            const mcfunction = new index_1.MCFunctionClass(this.datapack, this.getName(name), callback, options !== null && options !== void 0 ? options : {});
            this.datapack.rootFunctions.add(mcfunction);
            const returnFunction = mcfunction.call;
            returnFunction.schedule = mcfunction.schedule;
            // Set the function's name
            const descriptor = Object.getOwnPropertyDescriptor(returnFunction, 'name');
            descriptor.value = mcfunction.name;
            Object.defineProperty(returnFunction, 'name', descriptor);
            returnFunction.clearSchedule = mcfunction.clearSchedule;
            returnFunction.generate = mcfunction.generate;
            returnFunction.toString = mcfunction.toString;
            returnFunction.toJSON = mcfunction.toJSON;
            return returnFunction;
        };
        /**
         * Create an advancement.
         *
         * @param advancement The actual advancement. You must provide at least a `criteria` for it to be valid.
         *
         * @example
         *
         * Advancement('bred_two_cows', {
         *   criteria: {
         *     'bred_cows': {
         *       trigger: 'minecraft:bred_animals',
         *       conditions: {
         *         child: { type: 'minecraft:cow' }
         *       }
         *     }
         *   }
         * })
         */
        this.Advancement = (name, advancement) => new index_1.AdvancementClass(this.datapack, this.getName(name), advancement);
        /**
         * Create a predicate.
         *
         * @param predicate The actual predicate. You must provide at least a `condition` for it to be valid.
         *
         * @example
         *
         * Predicate('is_raining', {
         *   condition: 'minecraft:weather_check',
         *   raining: true,
         * })
         */
        this.Predicate = (name, predicate) => new index_1.PredicateClass(this.datapack, this.getName(name), predicate);
        /** Create a tag. */
        this.Tag = (type, name, values = [], replace) => new index_1.TagClass(this.datapack, type, this.getName(name), values, replace);
        /**
         * Create a loot table.
         *
         * @param lootTable The actual loot table. Each pool must provide a number of `rolls` and a list of `entries` to be valid.
         * Each entry must at least provide its `type` and the type-dependant required properties.
         *
         * @example
         *
         * LootTable('give_diamond', {
         *   pools: [{
         *     rolls: 1,
         *     entries: [{
         *       type: 'item',
         *       name: 'minecraft:diamond',
         *     }],
         *   }],
         * })
         */
        this.LootTable = (name, lootTable) => new index_1.LootTableClass(this.datapack, this.getName(name), lootTable);
        /** Create a recipe. */
        this.Recipe = (name, recipe) => new index_1.RecipeClass(this.datapack, this.getName(name), recipe);
        this.datapack = datapack;
        this.namespace = basePath.namespace;
        // Remove forward & trailing slashes
        this.directory = (typeof basePath.directory === 'string' ? trimSlashes(basePath.directory) : undefined);
    }
    /** Validates & crafts the name of a resource. */
    getName(name) {
        var _a;
        if (this.namespace !== undefined && name.includes(':')) {
            throw new Error('Cannot define namespace under a base path.');
        }
        const resourcePath = this.datapack.getResourcePath(name);
        // Find the new path
        const path = [this.directory, ...resourcePath.fullPath].filter((x) => x !== undefined).join('/');
        // Find the new namespace
        const namespace = (_a = this.namespace) !== null && _a !== void 0 ? _a : resourcePath.namespace;
        // Validate them both
        /**
         * A namespace should only contain the following symbols:
         *
         * 0123456789 (Numbers)
         * abcdefghijklmnopqrstuvwxyz (Lowercase letters)
         * _ (Underscore)
         * - (Hyphen/minus)
         */
        if (!namespace.match(/^[0-9a-z_-]+$/)) {
            throw new Error(`A namespace should only contain numbers, lowercase letters, underscores and hyphen/minus, and be at least 1 caracter long: got "${namespace}"`);
        }
        /**
         * For resources:
         * You can name anything (recipes, advancements, etc) whatever name you like, but these are the only officially supported symbols:
         *
         * 0123456789 (Numbers)
         * abcdefghijklmnopqrstuvwxyz (Lowercase letters)
         * _ (Underscore)
         * / (Forward slash, directory separator)
         * . (Period)
         * - (Hyphen/minus)
         */
        if (!path.length) {
            throw new Error('Empty name is not allowed.');
        }
        if (!path.match(/^[0-9a-z_\-/.]+$/)) {
            throw new Error(`Resources names can only contain numbers, lowercase letters, underscores, forward slash, period, and hyphens: got "${path}"`);
        }
        // Two consecutive dots are not allowed (Minecraft won't recognize the function)
        if (path.includes('..')) {
            throw new Error(`Resources names cannot inclue two consecutive dots: got "${path}"`);
        }
        if (!this.namespace && !name.includes(':')) {
            // No namespace has been provided, directly return the path.
            return path;
        }
        return `${namespace}:${path}`;
    }
}
exports.BasePathClass = BasePathClass;
