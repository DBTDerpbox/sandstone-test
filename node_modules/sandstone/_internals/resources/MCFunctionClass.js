"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCFunctionClass = void 0;
const util_1 = __importDefault(require("util"));
class MCFunctionClass {
    constructor(datapack, name, callback, options) {
        /**
         * Call the actual function overload. Returns different informations about it.
         */
        this.generate = () => {
            var _a;
            const { commandsRoot } = this.datapack;
            if (this.alreadyInitialized) {
                return undefined;
            }
            // Get the given tags
            let tags = (_a = this.options.tags) !== null && _a !== void 0 ? _a : [];
            // If it should run each tick, add it to the tick.json function
            const { runEach: runEachDelay } = this.options;
            if (runEachDelay !== undefined) {
                if (typeof runEachDelay && runEachDelay < 0) {
                    throw new Error(`\`runEach\` argument must be greater than 0, got ${runEachDelay}`);
                }
                if (this.options.runOnLoad !== false) {
                    // If run on load, call it directly
                    this.datapack.initCommands.push(['function', this.name]);
                }
            }
            else {
                // If runEachTick is specified, add to minecraft:tick
                if (this.options.runEachTick) {
                    tags = [...tags, 'minecraft:tick'];
                }
                // Idem for load
                if (this.options.runOnLoad) {
                    tags = [...tags, 'minecraft:load'];
                }
            }
            for (const tag of tags) {
                if (typeof tag === 'string') {
                    this.datapack.addFunctionToTag(this.name, tag);
                }
                else {
                    tag.values.push(this.name);
                }
            }
            const previousFunction = this.datapack.currentFunction;
            this.datapack.currentFunction = this.resource;
            // Add some comments specifying the overload, and the options
            if (this.options.debug) {
                commandsRoot.comment('Options:', JSON.stringify(this.options));
            }
            const result = this.callback();
            // If the command was scheduled to run each n ticks, add the /schedule command
            if (runEachDelay) {
                this.datapack.commandsRoot.schedule.function(this.name, runEachDelay, 'append');
            }
            const afterCall = () => {
                // If there is an unfinished command, register it
                commandsRoot.register(true);
                // Then back to the previous one
                this.datapack.currentFunction = previousFunction;
            };
            if (util_1.default.types.isAsyncFunction(this.callback)) {
                return result.then(afterCall);
            }
            return afterCall();
        };
        this.call = () => {
            this.datapack.commandsRoot.functionCmd(this.name);
        };
        this.schedule = (delay, type) => {
            this.datapack.commandsRoot.schedule.function(this.name, delay, type);
        };
        this.clearSchedule = () => {
            this.datapack.commandsRoot.schedule.clear(this.name);
        };
        this.toString = () => this.name;
        this.toJSON = this.toString;
        this.options = { lazy: false, debug: process.env.NODE_ENV === 'development', ...options };
        this.alreadyInitialized = false;
        this.callback = callback;
        this.datapack = datapack;
        // We "reserve" the folder by creating an empty folder there. It can be later changed to be a resource.
        const functionsPaths = datapack.getResourcePath(name);
        this.resource = datapack.resources.addResource('functions', {
            children: new Map(), isResource: true, path: functionsPaths.fullPathWithNamespace, commands: [],
        });
        this.name = functionsPaths.fullName;
    }
}
exports.MCFunctionClass = MCFunctionClass;
