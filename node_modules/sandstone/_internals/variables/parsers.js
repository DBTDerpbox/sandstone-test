"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangeParser = exports.sanitizeValue = exports.nbtParser = exports.rotationParser = exports.coordinatesParser = exports.arrayToArgsParser = void 0;
const util_1 = __importDefault(require("util"));
const Coordinates_1 = require("./Coordinates");
// PARSERS
function arrayToArgsParser(args) {
    if (Array.isArray(args) && args.length === 3) {
        return new Coordinates_1.VectorClass(args.map((arg) => arg.toString()));
    }
    return args;
}
exports.arrayToArgsParser = arrayToArgsParser;
function isRawCoordinates(arg) {
    return Array.isArray(arg) && arg.length === 3 && arg.every((c) => typeof c === 'string');
}
function isRawRotation(arg) {
    return Array.isArray(arg) && arg.length === 2 && arg.every((c) => typeof c === 'string');
}
function coordinatesParser(coordinates) {
    return isRawCoordinates(coordinates) ? new Coordinates_1.VectorClass(coordinates) : coordinates;
}
exports.coordinatesParser = coordinatesParser;
function rotationParser(rotation) {
    return isRawRotation(rotation) ? new Coordinates_1.VectorClass(rotation) : rotation;
}
exports.rotationParser = rotationParser;
const nbtParser = (nbt) => util_1.default.inspect(nbt, {
    depth: null,
    showHidden: false,
    compact: true,
    maxArrayLength: null,
    maxStringLength: null,
    breakLength: Infinity,
    colors: false,
});
exports.nbtParser = nbtParser;
// Sanitize score values. null => '', Infinity => '', any number => itself
const sanitizeValue = (value) => {
    if (value === undefined || value === null) {
        return '';
    }
    if (Number.isFinite(value)) {
        return value.toString();
    }
    // Value is Infinity or -Infinity
    return '';
};
exports.sanitizeValue = sanitizeValue;
// Returns the string representation of a range. [0, null] => '0..', [-Infinity, 5] => '..5', 8 => '8'
const rangeParser = (range) => {
    if (Array.isArray(range)) {
        return `${exports.sanitizeValue(range[0])}..${exports.sanitizeValue(range[1])}`;
    }
    return range.toString();
};
exports.rangeParser = rangeParser;
